0 Hash
1 table
2 Not
3 to
4 be
5 confused
6 with
7 Hash
8 list
9 or
10 Hash
11 tree
12 Hash
13 table
14 Type
15 Unordered
16 associative
17 array
18 Invented
19 1953
20 A
21 small
22 phone
23 book
24 as
25 a
26 hash
27 table
28 In
29 computing
30 a
31 hash
32 table
33 hash
34 map
35 is
36 a
37 data
38 structure
39 used
40 to
41 implement
42 an
43 associative
44 array
45 a
46 structure
47 that
48 can
49 map
50 keys
51 to
52 values
53 A
54 hash
55 table
56 uses
57 a
58 hash
59 function
60 to
61 compute
62 an
63 index
64 into
65 an
66 array
67 of
68 buckets
69 or
70 slots
71 from
72 which
73 the
74 correct
75 value
76 can
77 be
78 found
79 Ideally
80 the
81 hash
82 function
83 will
84 assign
85 each
86 key
87 to
88 a
89 unique
90 bucket
91 but
92 this
93 situation
94 is
95 rarely
96 achievable
97 in
98 practice
99 usually
100 some
101 keys
102 will
103 hash
104 to
105 the
106 same
107 bucket
108 Instead
109 most
110 hash
111 table
112 designs
113 assume
114 that
115 hash
116 collisions
117 different
118 keys
119 that
120 are
121 assigned
122 by
123 the
124 hash
125 function
126 to
127 the
128 same
129 bucket
130 will
131 occur
132 and
133 must
134 be
135 accommodated
136 in
137 some
138 way
139 In
140 a
141 well
142 dimensioned
143 hash
144 table
145 the
146 average
147 cost
148 number
149 of
150 instructions
151 for
152 each
153 lookup
154 is
155 independent
156 of
157 the
158 number
159 of
160 elements
161 stored
162 in
163 the
164 table
165 Many
166 hash
167 table
168 designs
169 also
170 allow
171 arbitrary
172 insertions
173 and
174 deletions
175 of
176 key
177 value
178 pairs
179 at
180 amortized2
181 constant
182 average
183 cost
184 per
185 operation34
186 In
187 many
188 situations
189 hash
190 tables
191 turn
192 out
193 to
194 be
195 more
196 efficient
197 than
198 search
199 trees
200 or
201 any
202 other
203 table
204 lookup
205 structure
206 For
207 this
208 reason
209 they
210 are
211 widely
212 used
213 in
214 many
215 kinds
216 of
217 computer
218 software
219 particularly
220 for
221 associative
222 arrays
223 database
224 indexing
225 caches
226 and
227 sets
228 Hash
229 function
230 The
231 idea
232 of
233 hashing
234 is
235 to
236 distribute
237 the
238 entries
239 key
240 value
241 pairs
242 across
243 an
244 array
245 of
246 buckets
247 Given
248 a
249 key
250 the
251 algorithm
252 computes
253 an
254 index
255 that
256 suggests
257 where
258 the
259 entry
260 can
261 be
262 found
263 index
264 fkey
265 array
266 size
267 Often
268 this
269 is
270 done
271 in
272 two
273 steps
274 hash
275 hashfunckey
276 index
277 hash
278 array
279 size
280 In
281 this
282 method
283 the
284 hash
285 is
286 independent
287 of
288 the
289 array
290 size
291 and
292 it
293 is
294 then
295 reduced
296 to
297 an
298 index
299 a
300 number
301 between
302 0
303 and
304 array
305 size
306 1
307 using
308 the
309 modulo
310 operator
311 In
312 the
313 case
314 that
315 the
316 array
317 size
318 is
319 a
320 power
321 of
322 two
323 the
324 remainder
325 operation
326 is
327 reduced
328 to
329 masking
330 which
331 improves
332 speed
333 but
334 can
335 increase
336 problems
337 with
338 a
339 poor
340 hash
341 function
342 Choosing
343 a
344 good
345 hash
346 function
347 A
348 good
349 hash
350 function
351 and
352 implementation
353 algorithm
354 are
355 essential
356 for
357 good
358 hash
359 table
360 performance
361 but
362 may
363 be
364 difficult
365 to
366 achieve
367 A
368 basic
369 requirement
370 is
371 that
372 the
373 function
374 should
375 provide
376 a
377 uniform
378 distribution
379 of
380 hash
381 values
382 A
383 non
384 uniform
385 distribution
386 increases
387 the
388 number
389 of
390 collisions
391 and
392 the
393 cost
394 of
395 resolving
396 them
397 Uniformity
398 is
399 sometimes
400 difficult
401 to
402 ensure
403 by
404 design
405 but
406 may
407 be
408 evaluated
409 empirically
410 using
411 statistical
412 tests
413 eg
414 a
415 Pearsons
416 chi
417 squared
418 test
419 for
420 discrete
421 uniform
422 distributions56
423 The
424 distribution
425 needs
426 to
427 be
428 uniform
429 only
430 for
431 table
432 sizes
433 that
434 occur
435 in
436 the
437 application
438 In
439 particular
440 if
441 one
442 uses
443 dynamic
444 resizing
445 with
446 exact
447 doubling
448 and
449 halving
450 of
451 the
452 table
453 size
454 s
455 then
456 the
457 hash
458 function
459 needs
460 to
461 be
462 uniform
463 only
464 when
465 s
466 is
467 a
468 power
469 of
470 two
471 On
472 the
473 other
474 hand
475 some
476 hashing
477 algorithms
478 provide
479 uniform
480 hashes
481 only
482 when
483 s
484 is
485 a
486 prime
487 number7
488 For
489 open
490 addressing
491 schemes
492 the
493 hash
494 function
495 should
496 also
497 avoid
498 clustering
499 the
500 mapping
501 of
502 two
503 or
504 more
505 keys
506 to
507 consecutive
508 slots
509 Such
510 clustering
511 may
512 cause
513 the
514 lookup
515 cost
516 to
517 skyrocket
518 even
519 if
520 the
521 load
522 factor
523 is
524 low
525 and
526 collisions
527 are
528 infrequent
529 The
530 popular
531 multiplicative
532 hash3
533 is
534 claimed
535 to
536 have
537 particularly
538 poor
539 clustering
540 behavior7
541 Cryptographic
542 hash
543 functions
544 are
545 believed
546 to
547 provide
548 good
549 hash
550 functions
551 for
552 any
553 table
554 size
555 s
556 either
557 by
558 modulo
559 reduction
560 or
561 by
562 bit
563 masking
564 They
565 may
566 also
567 be
568 appropriate
569 if
570 there
571 is
572 a
573 risk
574 of
575 malicious
576 users
577 trying
578 to
579 sabotage
580 a
581 network
582 service
583 by
584 submitting
585 requests
586 designed
587 to
588 generate
589 a
590 large
591 number
592 of
593 collisions
594 in
595 the
596 servers
597 hash
598 tables
599 However
600 the
601 risk
602 of
603 sabotage
604 can
605 also
606 be
607 avoided
608 by
609 cheaper
610 methods
611 such
612 as
613 applying
614 a
615 secret
616 salt
617 to
618 the
619 data
620 or
621 using
622 a
623 universal
624 hash
625 function
626 Perfect
627 hash
628 function
629 If
630 all
631 keys
632 are
633 known
634 ahead
635 of
636 time
637 a
638 perfect
639 hash
640 function
641 can
642 be
643 used
644 to
645 create
646 a
647 perfect
648 hash
649 table
650 that
651 has
652 no
653 collisions
654 If
655 minimal
656 perfect
657 hashing
658 is
659 used
660 every
661 location
662 in
663 the
664 hash
665 table
666 can
667 be
668 used
669 as
670 well
671 Perfect
672 hashing
673 allows
674 for
675 constant
676 time
677 lookups
678 in
679 the
680 worst
681 case
682 This
683 is
684 in
685 contrast
686 to
687 most
688 chaining
689 and
690 open
691 addressing
692 methods
693 where
694 the
695 time
696 for
697 lookup
698 is
699 low
700 on
701 average
702 but
703 may
704 be
705 very
706 large
707 proportional
708 to
709 the
710 number
711 of
712 entries
713 for
714 some
715 sets
716 of
717 keys
718 Key
719 statistics
720 A
721 critical
722 statistic
723 for
724 a
725 hash
726 table
727 is
728 called
729 the
730 load
731 factor
732 This
733 is
734 simply
735 the
736 number
737 of
738 entries
739 divided
740 by
741 the
742 number
743 of
744 buckets
745 that
746 is
747 n
748 k
749 where
750 n
751 is
752 the
753 number
754 of
755 entries
756 and
757 k
758 is
759 the
760 number
761 of
762 buckets
763 If
764 the
765 load
766 factor
767 is
768 kept
769 reasonable
770 the
771 hash
772 table
773 should
774 perform
775 well
776 provided
777 the
778 hashing
779 is
780 good
781 If
782 the
783 load
784 factor
785 grows
786 too
787 large
788 the
789 hash
790 table
791 will
792 become
793 slow
794 or
795 it
796 may
797 fail
798 to
799 work
800 depending
801 on
802 the
803 method
804 used
805 The
806 expected
807 constant
808 time
809 property
810 of
811 a
812 hash
813 table
814 assumes
815 that
816 the
817 load
818 factor
819 is
820 kept
821 below
822 some
823 bound
824 For
825 a
826 fixed
827 number
828 of
829 buckets
830 the
831 time
832 for
833 a
834 lookup
835 grows
836 with
837 the
838 number
839 of
840 entries
841 and
842 so
843 does
844 not
845 achieve
846 the
847 desired
848 constant
849 time
850 Second
851 to
852 that
853 one
854 can
855 examine
856 the
857 variance
858 of
859 number
860 of
861 entries
862 per
863 bucket
864 For
865 example
866 two
867 tables
868 both
869 have
870 1000
871 entries
872 and
873 1000
874 buckets
875 one
876 has
877 exactly
878 one
879 entry
880 in
881 each
882 bucket
883 the
884 other
885 has
886 all
887 entries
888 in
889 the
890 same
891 bucket
892 Clearly
893 the
894 hashing
895 is
896 not
897 working
898 in
899 the
900 second
901 one
902 A
903 low
904 load
905 factor
906 is
907 not
908 especially
909 beneficial
910 As
911 the
912 load
913 factor
914 approaches
915 0
916 the
917 proportion
918 of
919 unused
920 areas
921 in
922 the
923 hash
924 table
925 increases
926 but
927 there
928 is
929 not
930 necessarily
931 any
932 reduction
933 in
934 search
935 cost
936 This
937 results
938 in
939 wasted
940 memory
941 Collision
942 resolution
943 Hash
944 collisions
945 are
946 practically
947 unavoidable
948 when
949 hashing
950 a
951 random
952 subset
953 of
954 a
955 large
956 set
957 of
958 possible
959 keys
960 For
961 example
962 if
963 2
964 450
965 keys
966 are
967 hashed
968 into
969 a
970 million
971 buckets
972 even
973 with
974 a
975 perfectly
976 uniform
977 random
978 distribution
979 according
980 to
981 the
982 birthday
983 problem
984 there
985 is
986 approximately
987 a
988 95
989 chance
990 of
991 at
992 least
993 two
994 of
995 the
996 keys
997 being
998 hashed
999 to
